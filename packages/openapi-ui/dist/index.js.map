{"version":3,"sources":["../src/parsing/parseOpenApi.ts","../src/context/ApiContext.ts","../src/context/ApiProvider.tsx","../src/hooks/useApiSpec.ts","../src/hooks/useEndpoints.ts","../src/hooks/useEndpoint.ts","../src/hooks/useSchema.ts","../src/components/EndpointList.tsx","../src/components/EndpointItem.tsx","../src/components/MethodBadge.tsx"],"names":["error","useContext","useMemo","jsx","jsxs"],"mappings":"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","file":"index.js","sourcesContent":["import {\n  OpenApiSpec,\n  NormalizedEndpoint,\n  NormalizedParameter,\n  NormalizedRequestBody,\n  NormalizedResponse,\n  NormalizedSchema,\n  NormalizedMediaType,\n  ParsedApiSpec,\n  HttpMethod,\n  Operation,\n  Parameter,\n  Reference,\n  Schema,\n  RequestBody,\n  Response,\n  MediaType,\n} from \"../types\";\n\n/**\n * Main function to parse and normalize an OpenAPI 3.x specification\n */\nexport function parseOpenApi(spec: OpenApiSpec): ParsedApiSpec {\n  const endpoints = extractEndpoints(spec);\n  const schemas = extractSchemas(spec);\n\n  return {\n    info: spec.info,\n    servers: spec.servers || [],\n    endpoints,\n    schemas,\n    tags: spec.tags || [],\n    securitySchemes: spec.components?.securitySchemes as\n      | Record<string, any>\n      | undefined,\n  };\n}\n\n/**\n * Extract and normalize all endpoints from the OpenAPI spec\n */\nfunction extractEndpoints(spec: OpenApiSpec): NormalizedEndpoint[] {\n  const endpoints: NormalizedEndpoint[] = [];\n\n  for (const [path, pathItem] of Object.entries(spec.paths)) {\n    const httpMethods: HttpMethod[] = [\n      \"get\",\n      \"post\",\n      \"put\",\n      \"delete\",\n      \"patch\",\n      \"options\",\n      \"head\",\n      \"trace\",\n    ];\n\n    for (const method of httpMethods) {\n      const operation = pathItem[method];\n      if (operation) {\n        const endpoint = normalizeEndpoint(path, method, operation, spec);\n        endpoints.push(endpoint);\n      }\n    }\n  }\n\n  return endpoints;\n}\n\n/**\n * Normalize a single endpoint operation\n */\nfunction normalizeEndpoint(\n  path: string,\n  method: HttpMethod,\n  operation: Operation,\n  spec: OpenApiSpec\n): NormalizedEndpoint {\n  const id = generateEndpointId(method, path, operation.operationId);\n\n  return {\n    id,\n    method,\n    path,\n    summary: operation.summary,\n    description: operation.description,\n    operationId: operation.operationId,\n    tags: operation.tags,\n    parameters: normalizeParameters(operation.parameters || [], spec),\n    requestBody: operation.requestBody\n      ? normalizeRequestBody(operation.requestBody, spec)\n      : undefined,\n    responses: normalizeResponses(operation.responses, spec),\n    deprecated: operation.deprecated || false,\n    security: operation.security,\n  };\n}\n\n/**\n * Generate a unique ID for an endpoint\n */\nfunction generateEndpointId(\n  method: HttpMethod,\n  path: string,\n  operationId?: string\n): string {\n  if (operationId) {\n    return operationId;\n  }\n  return `${method.toUpperCase()}_${path.replace(/[^a-zA-Z0-9]/g, \"_\")}`;\n}\n\n/**\n * Normalize parameters array\n */\nfunction normalizeParameters(\n  parameters: (Parameter | Reference)[],\n  spec: OpenApiSpec\n): NormalizedParameter[] {\n  return parameters.map((param) => {\n    const resolved = resolveReference(param, spec) as Parameter;\n    return {\n      name: resolved.name,\n      in: resolved.in,\n      description: resolved.description,\n      required: resolved.required || false,\n      deprecated: resolved.deprecated || false,\n      schema: resolved.schema\n        ? normalizeSchema(resolved.schema, spec)\n        : undefined,\n      example: resolved.example,\n    };\n  });\n}\n\n/**\n * Normalize request body\n */\nfunction normalizeRequestBody(\n  requestBody: RequestBody | Reference,\n  spec: OpenApiSpec\n): NormalizedRequestBody {\n  const resolved = resolveReference(requestBody, spec) as RequestBody;\n\n  return {\n    description: resolved.description,\n    required: resolved.required || false,\n    content: Object.entries(resolved.content).map(([mediaType, content]) =>\n      normalizeMediaType(mediaType, content, spec)\n    ),\n  };\n}\n\n/**\n * Normalize responses object\n */\nfunction normalizeResponses(\n  responses: Record<string, Response | Reference>,\n  spec: OpenApiSpec\n): NormalizedResponse[] {\n  return Object.entries(responses).map(([statusCode, response]) => {\n    const resolved = resolveReference(response, spec) as Response;\n\n    return {\n      statusCode,\n      description: resolved.description,\n      content: resolved.content\n        ? Object.entries(resolved.content).map(([mediaType, content]) =>\n            normalizeMediaType(mediaType, content, spec)\n          )\n        : undefined,\n      headers: resolved.headers\n        ? Object.fromEntries(\n            Object.entries(resolved.headers).map(([name, header]) => [\n              name,\n              {\n                name,\n                description: (resolveReference(header, spec) as any)\n                  .description,\n                required:\n                  (resolveReference(header, spec) as any).required || false,\n                schema: (resolveReference(header, spec) as any).schema\n                  ? normalizeSchema(\n                      (resolveReference(header, spec) as any).schema,\n                      spec\n                    )\n                  : undefined,\n                example: (resolveReference(header, spec) as any).example,\n              },\n            ])\n          )\n        : undefined,\n    };\n  });\n}\n\n/**\n * Normalize media type\n */\nfunction normalizeMediaType(\n  mediaType: string,\n  content: MediaType,\n  spec: OpenApiSpec\n): NormalizedMediaType {\n  return {\n    mediaType,\n    schema: content.schema ? normalizeSchema(content.schema, spec) : undefined,\n    example: content.example,\n    examples: content.examples\n      ? Object.fromEntries(\n          Object.entries(content.examples).map(([name, example]) => [\n            name,\n            (resolveReference(example, spec) as any).value || example,\n          ])\n        )\n      : undefined,\n  };\n}\n\n/**\n * Normalize schema object\n */\nfunction normalizeSchema(\n  schema: Schema | Reference,\n  spec: OpenApiSpec\n): NormalizedSchema {\n  const resolved = resolveReference(schema, spec) as Schema;\n\n  const normalized: NormalizedSchema = {\n    type: resolved.type,\n    format: resolved.format,\n    description: resolved.description,\n    example: resolved.example,\n    enum: resolved.enum,\n    required: resolved.required,\n    nullable: resolved.nullable,\n    deprecated: resolved.deprecated,\n    title: resolved.title,\n    default: resolved.default,\n    minimum: resolved.minimum,\n    maximum: resolved.maximum,\n    minLength: resolved.minLength,\n    maxLength: resolved.maxLength,\n    pattern: resolved.pattern,\n    minItems: resolved.minItems,\n    maxItems: resolved.maxItems,\n    uniqueItems: resolved.uniqueItems,\n  };\n\n  // Handle object properties\n  if (resolved.properties) {\n    normalized.properties = Object.fromEntries(\n      Object.entries(resolved.properties).map(([name, prop]) => [\n        name,\n        normalizeSchema(prop, spec),\n      ])\n    );\n  }\n\n  // Handle array items\n  if (resolved.items) {\n    normalized.items = normalizeSchema(resolved.items, spec);\n  }\n\n  // Handle additional properties\n  if (resolved.additionalProperties !== undefined) {\n    if (typeof resolved.additionalProperties === \"boolean\") {\n      normalized.additionalProperties = resolved.additionalProperties;\n    } else {\n      normalized.additionalProperties = normalizeSchema(\n        resolved.additionalProperties,\n        spec\n      );\n    }\n  }\n\n  // Handle composition schemas\n  if (resolved.allOf) {\n    normalized.allOf = resolved.allOf.map((s) => normalizeSchema(s, spec));\n  }\n  if (resolved.oneOf) {\n    normalized.oneOf = resolved.oneOf.map((s) => normalizeSchema(s, spec));\n  }\n  if (resolved.anyOf) {\n    normalized.anyOf = resolved.anyOf.map((s) => normalizeSchema(s, spec));\n  }\n\n  return normalized;\n}\n\n/**\n * Extract all schemas from components\n */\nfunction extractSchemas(spec: OpenApiSpec): Record<string, NormalizedSchema> {\n  if (!spec.components?.schemas) {\n    return {};\n  }\n\n  return Object.fromEntries(\n    Object.entries(spec.components.schemas).map(([name, schema]) => [\n      name,\n      normalizeSchema(schema, spec),\n    ])\n  );\n}\n\n/**\n * Resolve $ref references\n */\nfunction resolveReference<T>(item: T | Reference, spec: OpenApiSpec): T {\n  if (typeof item === \"object\" && item !== null && \"$ref\" in item) {\n    const ref = (item as Reference).$ref;\n    const path = ref.replace(\"#/\", \"\").split(\"/\");\n\n    let current: any = spec;\n    for (const segment of path) {\n      current = current[segment];\n      if (!current) {\n        throw new Error(`Unable to resolve reference: ${ref}`);\n      }\n    }\n\n    return current as T;\n  }\n\n  return item as T;\n}\n\n/**\n * Utility function to find an endpoint by ID\n */\nexport function findEndpointById(\n  endpoints: NormalizedEndpoint[],\n  id: string\n): NormalizedEndpoint | undefined {\n  return endpoints.find((endpoint) => endpoint.id === id);\n}\n\n/**\n * Utility function to find an endpoint by method and path\n */\nexport function findEndpointByMethodAndPath(\n  endpoints: NormalizedEndpoint[],\n  method: HttpMethod,\n  path: string\n): NormalizedEndpoint | undefined {\n  return endpoints.find(\n    (endpoint) => endpoint.method === method && endpoint.path === path\n  );\n}\n\n/**\n * Utility function to filter endpoints by tag\n */\nexport function filterEndpointsByTag(\n  endpoints: NormalizedEndpoint[],\n  tag: string\n): NormalizedEndpoint[] {\n  return endpoints.filter((endpoint) => endpoint.tags?.includes(tag));\n}\n\n/**\n * Utility function to group endpoints by tag\n */\nexport function groupEndpointsByTag(\n  endpoints: NormalizedEndpoint[]\n): Record<string, NormalizedEndpoint[]> {\n  const groups: Record<string, NormalizedEndpoint[]> = {};\n\n  for (const endpoint of endpoints) {\n    if (!endpoint.tags || endpoint.tags.length === 0) {\n      const untagged = groups[\"Untagged\"] || [];\n      untagged.push(endpoint);\n      groups[\"Untagged\"] = untagged;\n    } else {\n      for (const tag of endpoint.tags) {\n        const group = groups[tag] || [];\n        group.push(endpoint);\n        groups[tag] = group;\n      }\n    }\n  }\n\n  return groups;\n}\n","import { createContext } from \"react\";\nimport { ParsedApiSpec, NormalizedEndpoint, NormalizedSchema } from \"../types\";\n\nexport interface ApiContextValue {\n  spec: ParsedApiSpec | null;\n  loading: boolean;\n  error: string | null;\n\n  // Computed values\n  endpoints: NormalizedEndpoint[];\n  schemas: Record<string, NormalizedSchema>;\n\n  // Actions\n  setSpec: (spec: ParsedApiSpec) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: string | null) => void;\n\n  // Utilities\n  getEndpointById: (id: string) => NormalizedEndpoint | undefined;\n  getEndpointByMethodAndPath: (\n    method: string,\n    path: string\n  ) => NormalizedEndpoint | undefined;\n  getSchema: (name: string) => NormalizedSchema | undefined;\n  getEndpointsByTag: (tag: string) => NormalizedEndpoint[];\n}\n\nexport const ApiContext = createContext<ApiContextValue | null>(null);\n","import { useState, useCallback, useMemo, ReactNode } from \"react\";\nimport { ApiContext, ApiContextValue } from \"./ApiContext\";\nimport { ParsedApiSpec, OpenApiSpec } from \"../types\";\nimport {\n  parseOpenApi,\n  findEndpointById,\n  findEndpointByMethodAndPath,\n  filterEndpointsByTag,\n} from \"../parsing/parseOpenApi\";\n\nexport interface ApiProviderProps {\n  children: ReactNode;\n  spec?: OpenApiSpec | ParsedApiSpec;\n  onError?: (error: string) => void;\n}\n\nexport function ApiProvider({\n  children,\n  spec: initialSpec,\n  onError,\n}: ApiProviderProps) {\n  const [spec, setSpecState] = useState<ParsedApiSpec | null>(() => {\n    if (!initialSpec) return null;\n\n    // Check if it's already parsed\n    if (\"endpoints\" in initialSpec) {\n      return initialSpec as ParsedApiSpec;\n    }\n\n    // Parse OpenAPI spec\n    try {\n      return parseOpenApi(initialSpec as OpenApiSpec);\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error\n          ? error.message\n          : \"Failed to parse OpenAPI specification\";\n      onError?.(errorMessage);\n      return null;\n    }\n  });\n\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const setSpec = useCallback((newSpec: ParsedApiSpec) => {\n    setSpecState(newSpec);\n    setError(null);\n  }, []);\n\n  const setErrorState = useCallback(\n    (newError: string | null) => {\n      setError(newError);\n      if (newError) {\n        onError?.(newError);\n      }\n    },\n    [onError]\n  );\n\n  // Computed values\n  const endpoints = useMemo(() => spec?.endpoints || [], [spec]);\n  const schemas = useMemo(() => spec?.schemas || {}, [spec]);\n\n  // Utility functions\n  const getEndpointById = useCallback(\n    (id: string) => {\n      return findEndpointById(endpoints, id);\n    },\n    [endpoints]\n  );\n\n  const getEndpointByMethodAndPath = useCallback(\n    (method: string, path: string) => {\n      return findEndpointByMethodAndPath(\n        endpoints,\n        method.toLowerCase() as any,\n        path\n      );\n    },\n    [endpoints]\n  );\n\n  const getSchema = useCallback(\n    (name: string) => {\n      return schemas[name];\n    },\n    [schemas]\n  );\n\n  const getEndpointsByTag = useCallback(\n    (tag: string) => {\n      return filterEndpointsByTag(endpoints, tag);\n    },\n    [endpoints]\n  );\n\n  const contextValue: ApiContextValue = useMemo(\n    () => ({\n      spec,\n      loading,\n      error,\n      endpoints,\n      schemas,\n      setSpec,\n      setLoading,\n      setError: setErrorState,\n      getEndpointById,\n      getEndpointByMethodAndPath,\n      getSchema,\n      getEndpointsByTag,\n    }),\n    [\n      spec,\n      loading,\n      error,\n      endpoints,\n      schemas,\n      setSpec,\n      setErrorState,\n      getEndpointById,\n      getEndpointByMethodAndPath,\n      getSchema,\n      getEndpointsByTag,\n    ]\n  );\n\n  return (\n    <ApiContext.Provider value={contextValue}>{children}</ApiContext.Provider>\n  );\n}\n","import { useContext } from \"react\";\nimport { ApiContext } from \"../context/ApiContext\";\nimport { ParsedApiSpec } from \"../types\";\n\n/**\n * Hook to access the parsed API specification\n */\nexport function useApiSpec(): ParsedApiSpec | null {\n  const context = useContext(ApiContext);\n\n  if (!context) {\n    throw new Error(\"useApiSpec must be used within an ApiProvider\");\n  }\n\n  return context.spec;\n}\n","import { useContext, useMemo } from \"react\";\nimport { ApiContext } from \"../context/ApiContext\";\nimport { NormalizedEndpoint } from \"../types\";\n\nexport interface UseEndpointsOptions {\n  filter?: (endpoint: NormalizedEndpoint) => boolean;\n  tag?: string;\n  method?: string;\n  search?: string;\n}\n\n/**\n * Hook to access and filter the list of endpoints\n */\nexport function useEndpoints(\n  options: UseEndpointsOptions = {}\n): NormalizedEndpoint[] {\n  const context = useContext(ApiContext);\n\n  if (!context) {\n    throw new Error(\"useEndpoints must be used within an ApiProvider\");\n  }\n\n  const { filter, tag, method, search } = options;\n\n  return useMemo(() => {\n    let filtered = context.endpoints;\n\n    // Apply tag filter\n    if (tag) {\n      filtered = context.getEndpointsByTag(tag);\n    }\n\n    // Apply method filter\n    if (method) {\n      filtered = filtered.filter(\n        (endpoint) => endpoint.method.toLowerCase() === method.toLowerCase()\n      );\n    }\n\n    // Apply search filter\n    if (search) {\n      const searchLower = search.toLowerCase();\n      filtered = filtered.filter(\n        (endpoint) =>\n          endpoint.path.toLowerCase().includes(searchLower) ||\n          endpoint.summary?.toLowerCase().includes(searchLower) ||\n          endpoint.description?.toLowerCase().includes(searchLower) ||\n          endpoint.operationId?.toLowerCase().includes(searchLower)\n      );\n    }\n\n    // Apply custom filter function\n    if (filter) {\n      filtered = filtered.filter(filter);\n    }\n\n    return filtered;\n  }, [\n    context.endpoints,\n    context.getEndpointsByTag,\n    filter,\n    tag,\n    method,\n    search,\n  ]);\n}\n","import { useContext, useMemo } from \"react\";\nimport { ApiContext } from \"../context/ApiContext\";\nimport { NormalizedEndpoint, HttpMethod } from \"../types\";\n\nexport type EndpointIdentifier =\n  | string // operationId or endpoint ID\n  | { method: HttpMethod; path: string }; // method + path combination\n\n/**\n * Hook to access a specific endpoint by ID or method/path combination\n */\nexport function useEndpoint(\n  identifier: EndpointIdentifier\n): NormalizedEndpoint | undefined {\n  const context = useContext(ApiContext);\n\n  if (!context) {\n    throw new Error(\"useEndpoint must be used within an ApiProvider\");\n  }\n\n  return useMemo(() => {\n    if (typeof identifier === \"string\") {\n      // Search by ID or operationId\n      return context.getEndpointById(identifier);\n    } else {\n      // Search by method and path\n      return context.getEndpointByMethodAndPath(\n        identifier.method,\n        identifier.path\n      );\n    }\n  }, [context, identifier]);\n}\n","import { useContext } from \"react\";\nimport { ApiContext } from \"../context/ApiContext\";\nimport { NormalizedSchema } from \"../types\";\n\n/**\n * Hook to access a schema by name from the components.schemas section\n */\nexport function useSchema(name: string): NormalizedSchema | undefined {\n  const context = useContext(ApiContext);\n\n  if (!context) {\n    throw new Error(\"useSchema must be used within an ApiProvider\");\n  }\n\n  return context.getSchema(name);\n}\n\n/**\n * Hook to access all schemas\n */\nexport function useSchemas(): Record<string, NormalizedSchema> {\n  const context = useContext(ApiContext);\n\n  if (!context) {\n    throw new Error(\"useSchemas must be used within an ApiProvider\");\n  }\n\n  return context.schemas;\n}\n","import { useEndpoints } from \"../hooks/useEndpoints\";\nimport { NormalizedEndpoint, EndpointListProps } from \"../types\";\nimport { groupEndpointsByTag } from \"../parsing/parseOpenApi\";\n\n/**\n * Headless component for rendering a list of endpoints\n * Supports filtering, grouping, and custom render functions\n */\nexport function EndpointList({\n  endpoints: externalEndpoints,\n  filter,\n  groupBy,\n  children,\n  renderGroup,\n  className,\n  style,\n  ...props\n}: EndpointListProps) {\n  // Use provided endpoints or fetch from context\n  const contextEndpoints = useEndpoints({ filter });\n  const endpoints = externalEndpoints || contextEndpoints;\n\n  if (!endpoints.length) {\n    return null;\n  }\n\n  // Handle grouping\n  if (groupBy === \"tag\") {\n    const groups = groupEndpointsByTag(endpoints);\n\n    return (\n      <div className={className} style={style} {...props}>\n        {Object.entries(groups).map(([tagName, tagEndpoints]) => {\n          if (renderGroup) {\n            return renderGroup(tagName, tagEndpoints);\n          }\n\n          return (\n            <div key={tagName}>\n              <h3>{tagName}</h3>\n              {tagEndpoints.map((endpoint, index) => (\n                <div key={endpoint.id}>{children?.(endpoint, index)}</div>\n              ))}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n\n  if (groupBy === \"method\") {\n    const methodGroups = endpoints.reduce((groups, endpoint) => {\n      const method = endpoint.method.toUpperCase();\n      if (!groups[method]) {\n        groups[method] = [];\n      }\n      groups[method].push(endpoint);\n      return groups;\n    }, {} as Record<string, NormalizedEndpoint[]>);\n\n    return (\n      <div className={className} style={style} {...props}>\n        {Object.entries(methodGroups).map(([method, methodEndpoints]) => {\n          if (renderGroup) {\n            return renderGroup(method, methodEndpoints);\n          }\n\n          return (\n            <div key={method}>\n              <h3>{method}</h3>\n              {methodEndpoints.map((endpoint, index) => (\n                <div key={endpoint.id}>{children?.(endpoint, index)}</div>\n              ))}\n            </div>\n          );\n        })}\n      </div>\n    );\n  }\n\n  // Default: no grouping\n  return (\n    <div className={className} style={style} {...props}>\n      {endpoints.map((endpoint, index) => (\n        <div key={endpoint.id}>{children?.(endpoint, index)}</div>\n      ))}\n    </div>\n  );\n}\n","import { EndpointItemProps } from \"../types\";\n\n/**\n * Headless component for rendering a single endpoint item\n * Provides default structure but allows complete customization via render props\n */\nexport function EndpointItem({\n  endpoint,\n  children,\n  renderMethod,\n  renderPath,\n  renderSummary,\n  className,\n  style,\n  ...props\n}: EndpointItemProps) {\n  return (\n    <div\n      className={className}\n      style={style}\n      data-method={endpoint.method}\n      data-endpoint-id={endpoint.id}\n      {...props}\n    >\n      {renderMethod ? (\n        renderMethod(endpoint.method)\n      ) : (\n        <span>{endpoint.method.toUpperCase()}</span>\n      )}\n\n      {renderPath ? renderPath(endpoint.path) : <span>{endpoint.path}</span>}\n\n      {renderSummary\n        ? renderSummary(endpoint.summary)\n        : endpoint.summary && <span>{endpoint.summary}</span>}\n\n      {children}\n    </div>\n  );\n}\n","import { MethodBadgeProps } from \"../types\";\n\n/**\n * Headless component for rendering HTTP method badges\n * Provides a simple wrapper that can be styled with className\n */\nexport function MethodBadge({\n  method,\n  children,\n  className,\n  style,\n  ...props\n}: MethodBadgeProps) {\n  const methodUpper = method.toUpperCase();\n\n  return (\n    <span className={className} style={style} data-method={method} {...props}>\n      {children || methodUpper}\n    </span>\n  );\n}\n"]}